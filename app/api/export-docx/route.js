import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  LevelFormat,
} from "docx";

export async function POST(request) {
  try {
    const { title, content, toolName } = await request.json();

    if (!content) {
      return Response.json({ error: "Content is required" }, { status: 400 });
    }

    // Parse the markdown-like content into document structure
    const paragraphs = parseContentToParagraphs(content);

    // Create the document
    const doc = new Document({
      styles: {
        default: {
          document: {
            run: { font: "Arial", size: 24 }, // 12pt default
          },
        },
        paragraphStyles: [
          {
            id: "Heading1",
            name: "Heading 1",
            basedOn: "Normal",
            next: "Normal",
            quickFormat: true,
            run: { size: 32, bold: true, color: "000000", font: "Arial" },
            paragraph: { spacing: { before: 240, after: 120 } },
          },
          {
            id: "Heading2",
            name: "Heading 2",
            basedOn: "Normal",
            next: "Normal",
            quickFormat: true,
            run: { size: 28, bold: true, color: "333333", font: "Arial" },
            paragraph: { spacing: { before: 200, after: 100 } },
          },
          {
            id: "Heading3",
            name: "Heading 3",
            basedOn: "Normal",
            next: "Normal",
            quickFormat: true,
            run: { size: 26, bold: true, color: "444444", font: "Arial" },
            paragraph: { spacing: { before: 160, after: 80 } },
          },
        ],
      },
      numbering: {
        config: [
          {
            reference: "bullet-list",
            levels: [
              {
                level: 0,
                format: LevelFormat.BULLET,
                text: "•",
                alignment: AlignmentType.LEFT,
                style: {
                  paragraph: {
                    indent: { left: 720, hanging: 360 },
                  },
                },
              },
            ],
          },
          {
            reference: "numbered-list",
            levels: [
              {
                level: 0,
                format: LevelFormat.DECIMAL,
                text: "%1.",
                alignment: AlignmentType.LEFT,
                style: {
                  paragraph: {
                    indent: { left: 720, hanging: 360 },
                  },
                },
              },
            ],
          },
        ],
      },
      sections: [
        {
          properties: {
            page: {
              margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 },
            },
          },
          children: [
            // Document title
            new Paragraph({
              heading: HeadingLevel.HEADING_1,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 },
              children: [new TextRun({ text: title || toolName || "Document", bold: true })],
            }),
            // Generated content
            ...paragraphs,
            // Footer with generation info
            new Paragraph({
              spacing: { before: 600 },
              children: [
                new TextRun({
                  text: `Generated by Teacher AI Assistant • ${new Date().toLocaleDateString()}`,
                  size: 18,
                  color: "888888",
                  italics: true,
                }),
              ],
            }),
          ],
        },
      ],
    });

    // Generate the .docx buffer
    const buffer = await Packer.toBuffer(doc);

    // Return as downloadable file
    return new Response(buffer, {
      headers: {
        "Content-Type":
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "Content-Disposition": `attachment; filename="${sanitizeFilename(title || toolName || "document")}.docx"`,
      },
    });
  } catch (error) {
    console.error("Error generating docx:", error);
    return Response.json({ error: "Failed to generate document" }, { status: 500 });
  }
}

// Parse markdown-like content into docx paragraphs
function parseContentToParagraphs(content) {
  const lines = content.split("\n");
  const paragraphs = [];
  let currentListType = null;
  let listReference = "bullet-list";
  let listCounter = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();

    // Skip empty lines but add spacing
    if (!trimmedLine) {
      continue;
    }

    // Heading 1: ## or **SECTION**
    if (trimmedLine.startsWith("## ")) {
      paragraphs.push(
        new Paragraph({
          heading: HeadingLevel.HEADING_2,
          children: [new TextRun({ text: trimmedLine.replace("## ", ""), bold: true })],
        })
      );
      currentListType = null;
      continue;
    }

    // Heading 2: ### 
    if (trimmedLine.startsWith("### ")) {
      paragraphs.push(
        new Paragraph({
          heading: HeadingLevel.HEADING_3,
          children: [new TextRun({ text: trimmedLine.replace("### ", ""), bold: true })],
        })
      );
      currentListType = null;
      continue;
    }

    // Bold section headers like **SECTION NAME**
    if (trimmedLine.startsWith("**") && trimmedLine.endsWith("**") && !trimmedLine.includes(":** ")) {
      paragraphs.push(
        new Paragraph({
          spacing: { before: 200, after: 100 },
          children: [
            new TextRun({
              text: trimmedLine.replace(/\*\*/g, ""),
              bold: true,
              size: 26,
            }),
          ],
        })
      );
      currentListType = null;
      continue;
    }

    // Bullet points: - or •
    if (trimmedLine.startsWith("- ") || trimmedLine.startsWith("• ")) {
      if (currentListType !== "bullet") {
        listCounter++;
        listReference = `bullet-list-${listCounter}`;
        currentListType = "bullet";
      }
      paragraphs.push(
        new Paragraph({
          numbering: { reference: "bullet-list", level: 0 },
          children: [new TextRun(trimmedLine.replace(/^[-•]\s*/, ""))],
        })
      );
      continue;
    }

    // Numbered list: 1. or 1)
    if (/^\d+[.)]/.test(trimmedLine)) {
      if (currentListType !== "numbered") {
        listCounter++;
        currentListType = "numbered";
      }
      paragraphs.push(
        new Paragraph({
          numbering: { reference: "numbered-list", level: 0 },
          children: [new TextRun(trimmedLine.replace(/^\d+[.)]\s*/, ""))],
        })
      );
      continue;
    }

    // Regular paragraph with inline formatting
    currentListType = null;
    const textRuns = parseInlineFormatting(trimmedLine);
    paragraphs.push(
      new Paragraph({
        spacing: { after: 120 },
        children: textRuns,
      })
    );
  }

  return paragraphs;
}

// Parse inline formatting like **bold** and *italic*
function parseInlineFormatting(text) {
  const runs = [];
  let remaining = text;

  while (remaining.length > 0) {
    // Check for bold: **text**
    const boldMatch = remaining.match(/^\*\*([^*]+)\*\*/);
    if (boldMatch) {
      runs.push(new TextRun({ text: boldMatch[1], bold: true }));
      remaining = remaining.slice(boldMatch[0].length);
      continue;
    }

    // Check for field labels: **Label:** value
    const labelMatch = remaining.match(/^\*\*([^*]+):\*\*\s*/);
    if (labelMatch) {
      runs.push(new TextRun({ text: labelMatch[1] + ": ", bold: true }));
      remaining = remaining.slice(labelMatch[0].length);
      continue;
    }

    // Check for italic: *text*
    const italicMatch = remaining.match(/^\*([^*]+)\*/);
    if (italicMatch) {
      runs.push(new TextRun({ text: italicMatch[1], italics: true }));
      remaining = remaining.slice(italicMatch[0].length);
      continue;
    }

    // Find next formatting marker
    const nextMarker = remaining.search(/\*\*|\*/);
    if (nextMarker === -1) {
      // No more formatting, add rest as plain text
      runs.push(new TextRun(remaining));
      break;
    } else if (nextMarker > 0) {
      // Add plain text before next marker
      runs.push(new TextRun(remaining.slice(0, nextMarker)));
      remaining = remaining.slice(nextMarker);
    } else {
      // Unmatched marker, treat as plain text
      runs.push(new TextRun(remaining.charAt(0)));
      remaining = remaining.slice(1);
    }
  }

  return runs.length > 0 ? runs : [new TextRun(text)];
}

// Sanitize filename for download
function sanitizeFilename(name) {
  return name
    .replace(/[^a-z0-9\s-]/gi, "")
    .replace(/\s+/g, "_")
    .slice(0, 50);
}